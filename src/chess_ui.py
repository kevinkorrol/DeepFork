"""
Kivy-based chess UI for playing against the DeepFork MCTS agent.

This module provides a lightweight application that renders a chessboard and
lets a human play against a move generated by Monte Carlo Tree Search guided by
the DeepFork neural network.
"""

import random
import threading
import chess
import numpy as np
from kivy.app import App
from kivy.uix.floatlayout import FloatLayout
from kivy.core.window import Window
from kivy_chess_board import ChessBoard
from kivy.clock import Clock

from MCTS import MCTS
from model import DeepForkNet
from utils.chess_utils import get_state_hash

BOARD_SIZE = 600
NUM_SIM = 50


class ChessUI(App):
    """
    Simple Kivy application to play chess against the MCTS agent.

    :param player_color: Desired color for the human player. Use
                         'w' for white, 'b' for black, or 'r' for random.
    :param kwargs: Additional App kwargs passed to the Kivy base class
    """

    def __init__(self, player_color: str, **kwargs):
        super().__init__(**kwargs)
        self.board = chess.Board()
        self.cb = None
        self.player_color = player_color
        self.move_event = threading.Event()
        self.last_move = None
        self.color = random.choice(['w', 'b']) if player_color == 'r' else player_color
        self.history_count = 8
        self.states = {get_state_hash(chess.Board()): 1}
        self.history = np.zeros((self.history_count, 14, 8, 8), dtype=np.float32)
        self.model = DeepForkNet()
        self.on_start()


    def build(self):
        """
        Build the Kivy UI and initialize the interactive chessboard widget.

        :return: Root layout widget for the application
        """
        Window.size = (BOARD_SIZE, BOARD_SIZE)

        layout = FloatLayout()

        self.cb = ChessBoard(
            size=(BOARD_SIZE, BOARD_SIZE),
            size_hint=(None, None)
        )
        self.cb.inverted = self.player_color == 'b'
        self.cb.highlight_hover_when_dragged = True
        self.cb.update(self.board)

        self.cb.process_move_selection = self.process_move

        layout.add_widget(self.cb)
        return layout

    def process_move(self, cb: ChessBoard, move: chess.Move) -> None:
        """
        Handle a user's attempted move from the chessboard widget.

        If the move is legal, updates the internal board, refreshes the UI and
        schedules the agent's response move.

        :param cb: The chessboard widget
        :param move: The move selected by the user
        :return: None
        """
        if move in self.board.legal_moves:
            self.board.push(move)
            self.cb.board = self.board
            cb.update()
            self.last_move = move
            self.move_event.set()

            Clock.schedule_once(lambda x: self.clanker_make_move())

    def clanker_make_move(self):
        """
        Generate and play the agent's move using MCTS guided by the model.

        Stops early if the game is over or the 50-move rule threshold is met.
        """
        # Stop if game over
        if self.board.is_game_over() or self.board.halfmove_clock >= 200:
            return

        clanker_move = MCTS(
            self.board,
            NUM_SIM,
            self.model,
            'cpu',
            seen_states=self.states,
            state_history=self.history
        )

        self.board.push(clanker_move)
        self.cb.board = self.board
        self.cb.update()

    def on_start(self):
        """
        Kivy app lifecycle hook. If the human chose black, let the agent move first.
        """
        if self.player_color == 'b':
            Clock.schedule_once(lambda dt: self.clanker_make_move())


if __name__ == "__main__":
    ChessUI('w').run()
